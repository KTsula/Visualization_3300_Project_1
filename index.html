<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <title>Group Project</title>
  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>
</head>

<body>
  <p>
    <div style="display: flex; align-items: flex-start; margin: 20px;">
      <div style="flex: 1; margin-right: 20px;">
        <h3 style="font-family: Verdana;">Global Surface Temperature monthly change, 1880-2021</h3>
        <svg id="tempChart1" width="900" height="500"></svg>
        <svg id="colorLegend1" width="400" height="50" style="background: #fff; margin-top:10px; margin-left:50px;"></svg>
      </div>
      <div style="flex: 1;">
        <h3 style="font-family: Verdana;">Bi-Yearly average change compared to baseline</h3>
        <svg id="tempChart2" width="500" height="500"></svg>
      </div>
    </div>
    <script id="tempChart1_script">
      // Temperature Chart 1 (With gradually changing colored circles)
      const svg_1 = d3.select('svg#tempChart1');
      const width_1 = svg_1.attr('width');
      const height_1 = svg_1.attr('height');
      const margins_1 = { top: 10, right: 10, bottom: 60, left: 60 };
      const chartWidth_1 = width_1 - margins_1.left - margins_1.right;
      const chartHeight_1 = height_1 - margins_1.top - margins_1.bottom;
      let chartArea_1 = svg_1.append('g')
        .attr('transform', `translate(${margins_1.left},${margins_1.top})`);

      // Temperature Chart 2 (With bars)
      let svg_2 = d3.select('svg#tempChart2');
      let width_2 = svg_2.attr('width');
      let height_2 = svg_2.attr('height');
      let margins_2 = { top: 20, right: 20, bottom: 50, left: 50 };
      const chartWidth_2 = width_2 - margins_2.left - margins_2.right;
      const chartHeight_2 = height_2 - margins_2.top - margins_2.bottom;
      let chartArea_2 = svg_2.append('g')
        .attr('transform', `translate(${margins_2.left},${margins_2.top})`);

      d3.csv('GLB.Ts+dSST.csv')
        .then((data) => {

          /*
          ------------------------------
          Temperature Chart 1
          ------------------------------
          */

          // Months list (will simplify our life later)
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

          // Function to check if any value in the row is '***' (indicating missing data)
          function isValidRow(row) {
            return !months.some(month => row[month] === '***');
          }

          // Filter data to remove rows with missing data
          let filteredData = data
            .filter(isValidRow)  // Remove rows with '***'
            .map(d => ({
              year: +d.Year,
              temperatures: months.map(month => parseFloat(d[month]))  // Array of temperatures for each row
            }));
          
          console.log("Data: ", filteredData);

          // Grab max and min temperatures for scales
          const minTemp = d3.min(filteredData, d => d3.min(d.temperatures));
          const maxTemp = d3.max(filteredData, d => d3.max(d.temperatures));
          console.log("Min temp: ", minTemp);
          console.log("Max temp: ", maxTemp);

          // Grab the year extent
          const yearExtent = d3.extent(data, d => d.Year);

          // Set up scales
          let colorScale_1 = d3.scaleSequential(d3.interpolateViridis).domain([minTemp, maxTemp])

          let xScale_1 = d3.scaleLinear()
            .domain(yearExtent)
            .range([0, chartWidth_1]);

          let yScale_1 = d3.scalePoint()
            .domain(months)
            .range([chartHeight_1, 0])  // Spread the months evenly
            .padding(0.5);

          // Create X axis
          let bottomAxis_1 = d3.axisBottom(xScale_1)
            .tickFormat(d => d.toString()) // Format to show as integer
          svg_1.append('g')
            .attr('transform', `translate(${margins_1.left},${chartHeight_1 + margins_1.top + 10})`)
            .call(bottomAxis_1);

          // Create Y axis
          let leftAxis_1 = d3.axisLeft(yScale_1);
          svg_1.append('g')
            .attr('class', 'y axis')
            .attr('transform', `translate(${margins_1.left - 10}, ${margins_1.top})`)
            .call(leftAxis_1);

          // Create Gridlines
          let leftGridlines_1 = d3.axisLeft(yScale_1)
            .tickSize(-chartWidth_1 - 10)
            .tickFormat('');
          svg_1.append('g')
            .attr('class', 'y gridlines')
            .attr('transform', `translate(${margins_1.left - 10}, ${margins_1.top})`)
            .call(leftGridlines_1);

          let bottomGridlines_1 = d3.axisBottom(xScale_1)
            .tickSize(-chartHeight_1 - 10)
            .tickFormat('');
          svg_1.append('g')
            .attr('class', 'x gridlines')
            .attr('transform', `translate(${margins_1.left}, ${chartHeight_1 + margins_1.top + 10})`)
            .call(bottomGridlines_1);

          // Adding circles
          chartArea_1.selectAll('circle')
            .data(filteredData.flatMap(d => d.temperatures.map((temp, i) => ({
              year: d.year,
              month: months[i],
              temp: +temp
            }))))
            .enter()
            .append('circle')
            .attr('cx', d => xScale_1(d.year))
            .attr('cy', d => yScale_1(d.month))
            .attr('r', 5)
            .attr('fill', d => colorScale_1(d.temp));

          // Add color legend
          drawLegend("#colorLegend1", colorScale_1);

          // Add axis labels
          svg_1.append('text')
            .attr('class', 'x label')
            .attr('text-anchor', 'middle')
            .attr('x', chartWidth_1 / 2 + margins_1.left)
            .attr('y', chartHeight_1 + margins_1.top + 50)
            .text('Year')
            .style('font-family', 'Verdana')
            .style('font-size', '12');
            
          svg_1.append('text')
            .attr('class', 'y label')
            .attr('text-anchor', 'middle')
            .attr('transform', `rotate(-90)`)
            .attr('x', -chartHeight_1 / 2 - margins_1.top)
            .attr('y', margins_1.left - 50)
            .text('Month')
            .style('font-family', 'Verdana')
            .style('font-size', '12');


          /*
          ------------------------------
          Temperature Chart 2
          ------------------------------
          */

          // Calculate average temperature for each year
          let yearAvgTemp = filteredData.map(d => ({
            year: d.year,
            avgTemp: d.temperatures.reduce((sum, temp) => sum + temp, 0) / 12
          }));

          // Only grab years that are multiples of 5 (for better visibility of the chart)
          yearAvgTemp = yearAvgTemp.filter(d => d.year % 5 === 0);

          console.log("Yearly average temperature: ", yearAvgTemp);

          // Set up the scales
          const xScale_2 = d3.scaleLinear()
          .domain([d3.min(yearAvgTemp, d => d.year), d3.max(yearAvgTemp, d => d.year)])
          .range([0, chartWidth_2]);

          const yScale_2 = d3.scaleLinear()
          .domain([d3.min(yearAvgTemp, d => d.avgTemp), d3.max(yearAvgTemp, d => d.avgTemp)])
          .range([chartHeight_2-10, 0]);

          // Create X axis
          const bottomAxis_2 = d3.axisBottom(xScale_2).tickFormat(d => d.toString());
          chartArea_2.append('g')
          .attr('transform', `translate(0, ${chartHeight_2})`)
          .call(bottomAxis_2);

          // Create Y axis
          const leftAxis_2 = d3.axisLeft(yScale_2);
          chartArea_2.append('g')
            .attr('transform', `translate(-10, 0)`) // Shift left by 10 pixels
            .call(leftAxis_2);


          // Create horizontal line at y=0
          chartArea_2.append('line')
          .attr('x1', -10)
          .attr('x2', chartWidth_2+10)
          .attr('y1', yScale_2(0))
          .attr('y2', yScale_2(0))
          .style('stroke', 'black')
          .style('stroke-width', 1);

          // set width for bars
          const barWidth = 10;

          // Draw the bars using lines
          chartArea_2.selectAll('.bar')
          .data(yearAvgTemp)
          .enter()
          .append('line')
          .attr('class', 'bar')
          .attr('x1', d => xScale_2(d.year))
          .attr('x2', d => xScale_2(d.year))
          .attr('y1', yScale_2(0))
          .attr('y2', d => yScale_2(d.avgTemp))
          .attr('stroke', d => d.avgTemp > 0 ? d3.interpolateViridis(1) : d3.interpolateViridis(0))
          .attr('stroke-width', barWidth);

        });
    </script>
  </p>
  <p>
  <p style="font-family: Verdana; font-size: 13">This graph shows the correlation between carbon emissions and change in
    surface
    temperature from the previous year
    in the United States. It is predicted that as the amount of carbon emissions increases, the surface temperature
    increases as well.
  </p>
  <div style="display: flex; flex-direction: column; align-items: center;">
    <svg id="scatterplot" height="700" width="1300" style="margin-top:30px">
    </svg>
    <svg id="colorLegend2" width="400" height="50" style="background: #fff; margin-top:10px; margin-left:50px;"></svg>
  </div>

  <script>

    const svg_3 = d3.select('svg#scatterplot');
    const width_3 = svg_3.attr('width');
    const height_3 = svg_3.attr('height');
    const margins_3 = { top: 10, right: 20, bottom: 80, left: 80 };
    const chartWidth_3 = width_3 - margins_3.left - margins_3.right;
    const chartHeight_3 = height_3 - margins_3.top - margins_3.bottom;

    let annotations = svg_3.append("g").attr("id", "annotations");
    let chartArea_3 = svg_3.append("g").attr("id", "points")
      .attr("transform", `translate(${margins_3.left},${margins_3.top})`);

    Promise.all([d3.csv("USco2.csv", d3.autoType), d3.csv("UStemp.csv", d3.autoType)]).then(([co2data, tempdata]) => {

      console.log(co2data);
      console.log(tempdata);

      // need to reshape tempData
      const newTempData = [];
      tempdata.forEach(row => {
        const country = row["Country Name"];
        // loop through the years and create new data set where year is a column
        for (let year = 1970; year <= 2021; year++) {
          if (row[year] !== "") {
            newTempData.push({
              Country: country,
              Year: year,
              "Temp Change": row[year]
            });
          }
        }
      });
      //Merge data to have country, year, co2 and change in temperature
      const mergedData = co2data.map(co2Row => {
        const tempRow = newTempData.find(temp => temp.Country.toLowerCase().includes(co2Row.country_name.toLowerCase()) && temp.Year === co2Row.year);

        return {
          Country: co2Row.country_name,
          Year: co2Row.year,
          Co2: co2Row.value,
          TempChange: tempRow ? tempRow["Temp Change"] : null
        };
      }).filter(d => d.TempChange !== null);

      console.log(mergedData);



      //make co2 the y axis
      const co2Extent = d3.extent(mergedData, d => d.Co2);
      const co2Scale = d3.scaleLog().domain([Math.max(co2Extent[0] * 0.9, 0.1), co2Extent[1] * 1.1]).range([chartHeight_3, 0])

      let leftAxis_3 = d3.axisLeft(co2Scale)

      let leftGridlines_3 = d3.axisLeft(co2Scale)
        .tickSize(-chartWidth_3)
        .tickFormat("")
      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margins_3.left - 10},${margins_3.top})`)
        .call(leftAxis_3)
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", `translate(${margins_3.left - 10},${margins_3.top})`)
        .call(leftGridlines_3);

      //Add label to y axis
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("transform", `rotate(-90)`)
        .attr("x", -chartHeight_3 / 2 - margins_3.top)
        .attr("y", margins_3.left - 50)
        .text("CO2 Emissions (kt)")
        .style("font-family", "Verdana")
        .style("font-size", "12")

        
        

      // Dynamically compute the extent of years in your data
      const yearExtent_3 = d3.extent(mergedData, d => d.Year);

      // Create a scale for the years dynamically using the extent
      const yearScale = d3.scaleLinear().domain(yearExtent_3).range([0, chartWidth_3]);

      // Create the bottom axis with automatic ticks based on the year extent
      let bottomAxis_3 = d3.axisBottom(yearScale)
        .tickFormat(d3.format("d"));

      // Create bottom gridlines
      let bottomGridlines_3 = d3.axisBottom(yearScale)
        .tickSize(-chartHeight_3)
        .tickFormat("");

      // Append the axis to the chart
      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margins_3.left},${chartHeight_3 + margins_3.top})`)
        .call(bottomAxis_3);

      // Append the gridlines to the chart
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", `translate(${margins_3.left},${chartHeight_3 + margins_3.top})`)
        .call(bottomGridlines_3);


      // add label to x axis
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("x", chartWidth_3 / 2 + margins_3.left)
        .attr("y", chartHeight_3 + margins_3.top + 30)
        .text("Year")
        .style("font-family", "Verdana")
        .style("font-size", "12")

      //creating the color scale for the temperature changes
      const tempExtent_3 = d3.extent(mergedData, d => d.TempChange);
      const tempScale = d3.scaleLinear()
                          .domain(tempExtent_3)
                          .range([chartHeight_3, 0]);

      const colorScale_3 = d3.scaleSequential(d3.interpolateViridis)
        .domain([d3.min(tempExtent_3), d3.max(tempExtent_3)]);

      //plotting the circles correlated with their temperature change                   
      svg_3.selectAll('circle')
        .data(mergedData)
        .join('circle')
        .attr('cx', d => margins_3.left + yearScale(d.Year))
        .attr('cy', d => margins_3.top + co2Scale(d.Co2))
        .attr('r', 7)
        .style('fill', d => colorScale_3(d.TempChange));

      //legend for temperature
      drawLegend("#colorLegend2", colorScale_3);
    });

  </script>
  </p>

  <script>
    // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
    //   Released under MIT Free license
    //  Takes in an SVG element selector <legendSelector> and a d3 color scale <legendColorScale>
    //
    // Usage example: drawLegend("#legendID", grossIncomeColorScale)
    function drawLegend(legendSelector, legendColorScale) {
      
      // This code should adapt to a variety of different kinds of color scales
      //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS
      
      // Shrink legend bar by 5 px inwards from sides of SVG
      const offsets = { width: 10,
                        top: 2,
                        bottom: 24 }; 
      // Number of integer 'pixel steps' to draw when showing continuous scales
      //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
      const stepSize = 4; 
      // Extend the minmax by 0% in either direction to expose more features by default
      const minMaxExtendPercent = 0;
      
      const legend = d3.select(legendSelector);
      const legendHeight = legend.attr("height");
      const legendBarWidth = legend.attr("width") - (offsets.width * 2);
      const legendMinMax = d3.extent(legendColorScale.domain()); 
                  // recover the min and max values from most kinds of numeric scales
      const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
      const barHeight = legendHeight - offsets.top - offsets.bottom;     
      
      // In this case the "data" are pixels, and we get numbers to use in colorScale
      // Use this to make axis labels
      let barScale = d3.scaleLinear().domain([legendMinMax[0]-minMaxExtension,
                                                legendMinMax[1]+minMaxExtension])
                                     .range([0,legendBarWidth]);
      let barAxis = d3.axisBottom(barScale);
      
      // Place for bar slices to live
      let bar = legend.append("g")
                      .attr("class", "legend colorbar")
                      .attr("transform", `translate(${offsets.width},${offsets.top})`)
      
      // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******
      
      // Check if we're using a binning scale - if so, we make blocks of color
      if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
        // Get the thresholds
        let thresholds = [];
        if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
        else { thresholds = legendColorScale.quantiles() }
        
        const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];
        
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(barThresholds);
        
        // Draw rectangles between the threshold segments
        for (let i=0; i<barThresholds.length-1; i++) {
          let dataStart = barThresholds[i];
          let dataEnd = barThresholds[i+1];
          let pixelStart = barAxis.scale()(dataStart);
          let pixelEnd = barAxis.scale()(dataEnd);
          
          bar.append("rect")
            .attr("x", pixelStart)
            .attr("y", 0)
            .attr("width", pixelEnd - pixelStart )
            .attr("height", barHeight)
            .style("fill", legendColorScale( (dataStart + dataEnd) / 2.0 ) ); 
        }
      }
      // Else if we have a continuous / roundable scale
      //  In an ideal world you might construct a custom gradient mapped to the scale
      //  For this one, we use a hack of making stepped rects
      else if (legendColorScale.hasOwnProperty('rangeRound')) {
        // NOTE: The barAxis may round min and max values to make them pretty
        // ** This also means there is a risk of the legend going beyond scale bounds
        // We need to use the barAxis min and max just to be sure the bar is complete
        //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
        // ** We also need to create patches for the scale if the labels exceed bounds
        //     (floating point comparisons risky for small data ranges,but not a big deal
        //      because patches will be indistinguishable from actual scale bottom)
        // It's likely that scale clamping will actually do this for us elegantly
        // ...but better to be safer and patch the regions anyways
        
        for (let i=0; i<legendBarWidth; i=i+stepSize) {
          
          let center = i+(stepSize/2);
          let dataCenter = barAxis.scale().invert( center );
          
          // below normal scale bounds
          if ( dataCenter < legendMinMax[0] ) { 
            bar.append("rect")
              .attr("x", i)
              .attr("y", 0)
              .attr("width", stepSize)
              .attr("height",barHeight)
              .style("fill", legendColorScale( legendMinMax[0] ) ); 
          }
          // within normal scale bounds
          else if ( dataCenter < legendMinMax[1] ) {
            bar.append("rect")
                .attr("x", i)
                .attr("y", 0)
                .attr("width", stepSize)
                .attr("height",barHeight)
                .style("fill", legendColorScale( dataCenter ) ); 
          }
          // above normal scale bounds
          else {
            bar.append("rect")
                .attr("x", i)
                .attr("y", 0)
                .attr("width", stepSize)
                .attr("height",barHeight)
                .style("fill", legendColorScale( legendMinMax[1] ) ); 
          }
          
        }
      }
      // Otherwise we have a nominal scale
      else {
        let nomVals = legendColorScale.domain().sort();
        
        // Use a scaleBand to make blocks of color and simple labels
        let barScale = d3.scaleBand().domain(nomVals)
                                      .range([0,legendBarWidth])
                                      .padding(0.05);
        barAxis.scale(barScale);
        
        // Draw rectangles for each nominal entry
        nomVals.forEach( d => {
          bar.append("rect")
            .attr("x", barScale(d) )
            .attr("y", 0)
            .attr("width", barScale.bandwidth() )
            .attr("height", barHeight)
            .style("fill", legendColorScale( d ) );
        });
      }
      // DONE w/SWITCH
      
      // Finally, draw legend labels
      legend.append("g")
            .attr("class", "legend axis")
            .attr("transform",`translate(${offsets.width},${offsets.top+barHeight+5})`)
            .call(barAxis);
      
    }
    </script>
</body>
</html>