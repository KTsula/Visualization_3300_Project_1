<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    .gridlines .domain {
      display: none;
    }

    .gridlines line {
      stroke: #aaa;
    }
  </style>
</head>

<body>
  <h3>Alexa Bunda, abt53, Keti Sulamanidze, Sasha Bykhovski sb887, Nicole Gerber</h3>

  <p>CO2 and Surface Temperature Scatterplot:</p>
  <svg id="scatterplot" height="500" width="1000" style="margin-top:50px">
  </svg>

  <script>

    const svg = d3.select('svg#scatterplot');
    const width = svg.attr('width');
    const height = svg.attr('height');
    const margins = { top: 10, right: 10, bottom: 50, left: 50 };
    const chartWidth = width - margins.left - margins.right;
    const chartHeight = height - margins.top - margins.bottom;

    let annotations = svg.append("g").attr("id", "annotations");
    let chartArea = svg.append("g").attr("id", "points")
      .attr("transform", `translate(${margins.left},${margins.top})`);

    Promise.all([d3.csv("USco2.csv", d3.autoType), d3.csv("UStemp.csv", d3.autoType)]).then(([co2data, tempdata]) => {

      console.log(co2data);
      console.log(tempdata);

      // need to reshape tempData
      const newTempData = [];
      tempdata.forEach(row => {
        const country = row["Country Name"];
        // loop through the years and create new data set where year is a column
        for (let year = 1970; year <= 2021; year++) {
          if (row[year] !== "") {
            newTempData.push({
              Country: country,
              Year: year,
              "Temp Change": row[year]
            });
          }
        }
      });
      //Merge data to have country, year, co2 and change in temperature
      const mergedData = co2data.map(co2Row => {
        const tempRow = newTempData.find(temp => temp.Country.toLowerCase().includes(co2Row.country_name.toLowerCase()) && temp.Year === co2Row.year);

        return {
          Country: co2Row.country_name,
          Year: co2Row.year,
          Co2: co2Row.value,
          TempChange: tempRow ? tempRow["Temp Change"] : null
        };
      }).filter(d => d.TempChange !== null);

      console.log(mergedData);

      //make co2 the y axis
      const co2Extent = d3.extent(mergedData, d => d.Co2);
      const co2Scale = d3.scaleLog().domain(co2Extent).range([chartHeight, 0])

      let leftAxis = d3.axisLeft(co2Scale)

      let leftGridlines = d3.axisLeft(co2Scale)
        .tickSize(-chartWidth - 10)
        .tickFormat("")
      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margins.left - 10},${margins.top})`)
        .call(leftAxis)
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", `translate(${margins.left - 10},${margins.top})`)
        .call(leftGridlines);


      // const tempExtent = d3.extent(mergedData, d => d.TempChange)
      // const tempScale = d3.scaleLinear().domain(tempExtent).range([0, chartWidth]);

      //make the years increase by 2 on the x axis
      const yearScale = d3.scaleLinear().domain([1970, 2021]).range([0, chartWidth]);
      let years = d3.range(1970, 2022, 2);

      let bottomAxis = d3.axisBottom(yearScale)
        .tickValues(years)
        .tickSize(-chartHeight - 10)
        .tickFormat(d3.format("d"));

      let bottomGridlines = d3.axisBottom(yearScale)
        .tickValues(years)
        .tickSize(-chartHeight - 10)
        .tickFormat("")
        .ticks(6)
      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomGridlines);

    })



    // let leftAxis = d3.axisLeft(yScale);
    // svg.append('g')
    //   .attr('class', 'y axis')
    //   .attr('transform', `translate(${margins.left - 10},${margins.top})`)
    //   .call(leftAxis);
    // put in random values before cleaning the data

    // const xScale = d3.scaleLinear()
    // .domain([0, 40])
    // .range([0, chartWidth]);

    // const yScale = d3.scaleLinear()
    // .domain([0, 50])
    // .range([chartHeight, 0]);


    // let leftAxis = d3.axisLeft(yScale);
    //   svg.append('g')
    //     .attr('class', 'y axis')
    //     .attr('transform', `translate(${margins.left - 10},${margins.top})`)
    //     .call(leftAxis);

    // let bottomAxis = d3.axisBottom(xScale);
    // svg.append('g')
    //   .attr('class', 'x axis')
    //   .attr('transform', `translate(${margins.left},${margins.top + chartHeight + 10})`)
    //   .call(bottomAxis);




    // let leftGridlines = d3.axisLeft(yScale)
    //   .tickFormat("")
    //   .tickSize(-chartWidth - 10);
    // svg.append('g')
    //   .attr('class', 'y gridlines')
    //   .attr('transform', `translate(${margins.left - 10},${margins.top})`)
    //   .call(leftGridlines);

    // let bottomGridlines = d3.axisBottom(xScale)
    //   .tickFormat("")
    //   .tickSize(-chartHeight - 10)
    //   .ticks(6);
    // svg.append('g')
    //   .attr('class', 'x gridlines')
    //   .attr('transform', `translate(${margins.left},${margins.top + chartHeight + 10})`)
    //   .call(bottomGridlines);


    // let chartArea = svg.append('g')
    //   .attr('transform', `translate(${margins.left},${margins.top})`);
  </script>
  </p>



</body>

</html>